//指定的当前proto语法的版本, 有2和3

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: BurpMorePossibility.proto

//包名 服务名称 用于http2路由

package BurpMorePossibilityApi

import (
	context "context"
	HttpStructureStandard "github.com/kaliwin/Needle/PublicStandard/HttpStructureStandard/grpc/HttpStructureStandard"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BurpServer_RegisterRealTimeTrafficMirroring_FullMethodName = "/BurpMorePossibilityApi.BurpServer/RegisterRealTimeTrafficMirroring"
	BurpServer_RegisterServerList_FullMethodName               = "/BurpMorePossibilityApi.BurpServer/RegisterServerList"
	BurpServer_GetProxyHistory_FullMethodName                  = "/BurpMorePossibilityApi.BurpServer/GetProxyHistory"
	BurpServer_ReportIssue_FullMethodName                      = "/BurpMorePossibilityApi.BurpServer/ReportIssue"
)

// BurpServerClient is the client API for BurpServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BurpServerClient interface {
	// 注册实时流量传输
	// burp将监听端口通过服务端端流进行实时流量镜像
	RegisterRealTimeTrafficMirroring(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (BurpServer_RegisterRealTimeTrafficMirroringClient, error)
	// 服务注册列表 包含多个服务  多个服务其中有一个注册失败不会影响到已经成功的 只要有一个失败便会返回false
	RegisterServerList(ctx context.Context, in *ServiceRegisterRoutingList, opts ...grpc.CallOption) (*HttpStructureStandard.ProcessingStatus, error)
	// 获取代理历史请求 由于过滤会很复杂因此直接返回所有历史数据 入参为只占位符不用理睬
	// 由于数据过大默认单个消息最大为500MB 客户端也需要处理 后续将提供分块传输 过滤提取等方式
	// 修改为服务端流的方式进行流量传输
	GetProxyHistory(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (BurpServer_GetProxyHistoryClient, error)
	ReportIssue(ctx context.Context, in *HttpStructureStandard.AuditIssue, opts ...grpc.CallOption) (*HttpStructureStandard.ProcessingStatus, error)
}

type burpServerClient struct {
	cc grpc.ClientConnInterface
}

func NewBurpServerClient(cc grpc.ClientConnInterface) BurpServerClient {
	return &burpServerClient{cc}
}

func (c *burpServerClient) RegisterRealTimeTrafficMirroring(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (BurpServer_RegisterRealTimeTrafficMirroringClient, error) {
	stream, err := c.cc.NewStream(ctx, &BurpServer_ServiceDesc.Streams[0], BurpServer_RegisterRealTimeTrafficMirroring_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &burpServerRegisterRealTimeTrafficMirroringClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BurpServer_RegisterRealTimeTrafficMirroringClient interface {
	Recv() (*HttpStructureStandard.HttpReqAndRes, error)
	grpc.ClientStream
}

type burpServerRegisterRealTimeTrafficMirroringClient struct {
	grpc.ClientStream
}

func (x *burpServerRegisterRealTimeTrafficMirroringClient) Recv() (*HttpStructureStandard.HttpReqAndRes, error) {
	m := new(HttpStructureStandard.HttpReqAndRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *burpServerClient) RegisterServerList(ctx context.Context, in *ServiceRegisterRoutingList, opts ...grpc.CallOption) (*HttpStructureStandard.ProcessingStatus, error) {
	out := new(HttpStructureStandard.ProcessingStatus)
	err := c.cc.Invoke(ctx, BurpServer_RegisterServerList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *burpServerClient) GetProxyHistory(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (BurpServer_GetProxyHistoryClient, error) {
	stream, err := c.cc.NewStream(ctx, &BurpServer_ServiceDesc.Streams[1], BurpServer_GetProxyHistory_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &burpServerGetProxyHistoryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BurpServer_GetProxyHistoryClient interface {
	Recv() (*HttpStructureStandard.HttpReqAndRes, error)
	grpc.ClientStream
}

type burpServerGetProxyHistoryClient struct {
	grpc.ClientStream
}

func (x *burpServerGetProxyHistoryClient) Recv() (*HttpStructureStandard.HttpReqAndRes, error) {
	m := new(HttpStructureStandard.HttpReqAndRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *burpServerClient) ReportIssue(ctx context.Context, in *HttpStructureStandard.AuditIssue, opts ...grpc.CallOption) (*HttpStructureStandard.ProcessingStatus, error) {
	out := new(HttpStructureStandard.ProcessingStatus)
	err := c.cc.Invoke(ctx, BurpServer_ReportIssue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BurpServerServer is the server API for BurpServer service.
// All implementations must embed UnimplementedBurpServerServer
// for forward compatibility
type BurpServerServer interface {
	// 注册实时流量传输
	// burp将监听端口通过服务端端流进行实时流量镜像
	RegisterRealTimeTrafficMirroring(*HttpStructureStandard.Str, BurpServer_RegisterRealTimeTrafficMirroringServer) error
	// 服务注册列表 包含多个服务  多个服务其中有一个注册失败不会影响到已经成功的 只要有一个失败便会返回false
	RegisterServerList(context.Context, *ServiceRegisterRoutingList) (*HttpStructureStandard.ProcessingStatus, error)
	// 获取代理历史请求 由于过滤会很复杂因此直接返回所有历史数据 入参为只占位符不用理睬
	// 由于数据过大默认单个消息最大为500MB 客户端也需要处理 后续将提供分块传输 过滤提取等方式
	// 修改为服务端流的方式进行流量传输
	GetProxyHistory(*HttpStructureStandard.Str, BurpServer_GetProxyHistoryServer) error
	ReportIssue(context.Context, *HttpStructureStandard.AuditIssue) (*HttpStructureStandard.ProcessingStatus, error)
	mustEmbedUnimplementedBurpServerServer()
}

// UnimplementedBurpServerServer must be embedded to have forward compatible implementations.
type UnimplementedBurpServerServer struct {
}

func (UnimplementedBurpServerServer) RegisterRealTimeTrafficMirroring(*HttpStructureStandard.Str, BurpServer_RegisterRealTimeTrafficMirroringServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterRealTimeTrafficMirroring not implemented")
}
func (UnimplementedBurpServerServer) RegisterServerList(context.Context, *ServiceRegisterRoutingList) (*HttpStructureStandard.ProcessingStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterServerList not implemented")
}
func (UnimplementedBurpServerServer) GetProxyHistory(*HttpStructureStandard.Str, BurpServer_GetProxyHistoryServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProxyHistory not implemented")
}
func (UnimplementedBurpServerServer) ReportIssue(context.Context, *HttpStructureStandard.AuditIssue) (*HttpStructureStandard.ProcessingStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportIssue not implemented")
}
func (UnimplementedBurpServerServer) mustEmbedUnimplementedBurpServerServer() {}

// UnsafeBurpServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BurpServerServer will
// result in compilation errors.
type UnsafeBurpServerServer interface {
	mustEmbedUnimplementedBurpServerServer()
}

func RegisterBurpServerServer(s grpc.ServiceRegistrar, srv BurpServerServer) {
	s.RegisterService(&BurpServer_ServiceDesc, srv)
}

func _BurpServer_RegisterRealTimeTrafficMirroring_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HttpStructureStandard.Str)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BurpServerServer).RegisterRealTimeTrafficMirroring(m, &burpServerRegisterRealTimeTrafficMirroringServer{stream})
}

type BurpServer_RegisterRealTimeTrafficMirroringServer interface {
	Send(*HttpStructureStandard.HttpReqAndRes) error
	grpc.ServerStream
}

type burpServerRegisterRealTimeTrafficMirroringServer struct {
	grpc.ServerStream
}

func (x *burpServerRegisterRealTimeTrafficMirroringServer) Send(m *HttpStructureStandard.HttpReqAndRes) error {
	return x.ServerStream.SendMsg(m)
}

func _BurpServer_RegisterServerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceRegisterRoutingList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BurpServerServer).RegisterServerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BurpServer_RegisterServerList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BurpServerServer).RegisterServerList(ctx, req.(*ServiceRegisterRoutingList))
	}
	return interceptor(ctx, in, info, handler)
}

func _BurpServer_GetProxyHistory_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HttpStructureStandard.Str)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BurpServerServer).GetProxyHistory(m, &burpServerGetProxyHistoryServer{stream})
}

type BurpServer_GetProxyHistoryServer interface {
	Send(*HttpStructureStandard.HttpReqAndRes) error
	grpc.ServerStream
}

type burpServerGetProxyHistoryServer struct {
	grpc.ServerStream
}

func (x *burpServerGetProxyHistoryServer) Send(m *HttpStructureStandard.HttpReqAndRes) error {
	return x.ServerStream.SendMsg(m)
}

func _BurpServer_ReportIssue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.AuditIssue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BurpServerServer).ReportIssue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BurpServer_ReportIssue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BurpServerServer).ReportIssue(ctx, req.(*HttpStructureStandard.AuditIssue))
	}
	return interceptor(ctx, in, info, handler)
}

// BurpServer_ServiceDesc is the grpc.ServiceDesc for BurpServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BurpServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.BurpServer",
	HandlerType: (*BurpServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterServerList",
			Handler:    _BurpServer_RegisterServerList_Handler,
		},
		{
			MethodName: "ReportIssue",
			Handler:    _BurpServer_ReportIssue_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterRealTimeTrafficMirroring",
			Handler:       _BurpServer_RegisterRealTimeTrafficMirroring_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProxyHistory",
			Handler:       _BurpServer_GetProxyHistory_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "BurpMorePossibility.proto",
}

const (
	HttpFlowOut_HttpFlowOut_FullMethodName = "/BurpMorePossibilityApi.HttpFlowOut/HttpFlowOut"
)

// HttpFlowOutClient is the client API for HttpFlowOut service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HttpFlowOutClient interface {
	HttpFlowOut(ctx context.Context, in *HttpStructureStandard.HttpReqAndRes, opts ...grpc.CallOption) (*HttpStructureStandard.Str, error)
}

type httpFlowOutClient struct {
	cc grpc.ClientConnInterface
}

func NewHttpFlowOutClient(cc grpc.ClientConnInterface) HttpFlowOutClient {
	return &httpFlowOutClient{cc}
}

func (c *httpFlowOutClient) HttpFlowOut(ctx context.Context, in *HttpStructureStandard.HttpReqAndRes, opts ...grpc.CallOption) (*HttpStructureStandard.Str, error) {
	out := new(HttpStructureStandard.Str)
	err := c.cc.Invoke(ctx, HttpFlowOut_HttpFlowOut_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HttpFlowOutServer is the server API for HttpFlowOut service.
// All implementations must embed UnimplementedHttpFlowOutServer
// for forward compatibility
type HttpFlowOutServer interface {
	HttpFlowOut(context.Context, *HttpStructureStandard.HttpReqAndRes) (*HttpStructureStandard.Str, error)
	mustEmbedUnimplementedHttpFlowOutServer()
}

// UnimplementedHttpFlowOutServer must be embedded to have forward compatible implementations.
type UnimplementedHttpFlowOutServer struct {
}

func (UnimplementedHttpFlowOutServer) HttpFlowOut(context.Context, *HttpStructureStandard.HttpReqAndRes) (*HttpStructureStandard.Str, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HttpFlowOut not implemented")
}
func (UnimplementedHttpFlowOutServer) mustEmbedUnimplementedHttpFlowOutServer() {}

// UnsafeHttpFlowOutServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HttpFlowOutServer will
// result in compilation errors.
type UnsafeHttpFlowOutServer interface {
	mustEmbedUnimplementedHttpFlowOutServer()
}

func RegisterHttpFlowOutServer(s grpc.ServiceRegistrar, srv HttpFlowOutServer) {
	s.RegisterService(&HttpFlowOut_ServiceDesc, srv)
}

func _HttpFlowOut_HttpFlowOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.HttpReqAndRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpFlowOutServer).HttpFlowOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpFlowOut_HttpFlowOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpFlowOutServer).HttpFlowOut(ctx, req.(*HttpStructureStandard.HttpReqAndRes))
	}
	return interceptor(ctx, in, info, handler)
}

// HttpFlowOut_ServiceDesc is the grpc.ServiceDesc for HttpFlowOut service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HttpFlowOut_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.HttpFlowOut",
	HandlerType: (*HttpFlowOutServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HttpFlowOut",
			Handler:    _HttpFlowOut_HttpFlowOut_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	RealTimeTrafficMirroring_RealTimeTrafficMirroring_FullMethodName = "/BurpMorePossibilityApi.RealTimeTrafficMirroring/RealTimeTrafficMirroring"
)

// RealTimeTrafficMirroringClient is the client API for RealTimeTrafficMirroring service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RealTimeTrafficMirroringClient interface {
	// 实时流量传输
	// burp将主动建立连接通过客户端流进行实时流量镜像
	RealTimeTrafficMirroring(ctx context.Context, in *HttpStructureStandard.HttpReqAndRes, opts ...grpc.CallOption) (*HttpStructureStandard.Str, error)
}

type realTimeTrafficMirroringClient struct {
	cc grpc.ClientConnInterface
}

func NewRealTimeTrafficMirroringClient(cc grpc.ClientConnInterface) RealTimeTrafficMirroringClient {
	return &realTimeTrafficMirroringClient{cc}
}

func (c *realTimeTrafficMirroringClient) RealTimeTrafficMirroring(ctx context.Context, in *HttpStructureStandard.HttpReqAndRes, opts ...grpc.CallOption) (*HttpStructureStandard.Str, error) {
	out := new(HttpStructureStandard.Str)
	err := c.cc.Invoke(ctx, RealTimeTrafficMirroring_RealTimeTrafficMirroring_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RealTimeTrafficMirroringServer is the server API for RealTimeTrafficMirroring service.
// All implementations must embed UnimplementedRealTimeTrafficMirroringServer
// for forward compatibility
type RealTimeTrafficMirroringServer interface {
	// 实时流量传输
	// burp将主动建立连接通过客户端流进行实时流量镜像
	RealTimeTrafficMirroring(context.Context, *HttpStructureStandard.HttpReqAndRes) (*HttpStructureStandard.Str, error)
	mustEmbedUnimplementedRealTimeTrafficMirroringServer()
}

// UnimplementedRealTimeTrafficMirroringServer must be embedded to have forward compatible implementations.
type UnimplementedRealTimeTrafficMirroringServer struct {
}

func (UnimplementedRealTimeTrafficMirroringServer) RealTimeTrafficMirroring(context.Context, *HttpStructureStandard.HttpReqAndRes) (*HttpStructureStandard.Str, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RealTimeTrafficMirroring not implemented")
}
func (UnimplementedRealTimeTrafficMirroringServer) mustEmbedUnimplementedRealTimeTrafficMirroringServer() {
}

// UnsafeRealTimeTrafficMirroringServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RealTimeTrafficMirroringServer will
// result in compilation errors.
type UnsafeRealTimeTrafficMirroringServer interface {
	mustEmbedUnimplementedRealTimeTrafficMirroringServer()
}

func RegisterRealTimeTrafficMirroringServer(s grpc.ServiceRegistrar, srv RealTimeTrafficMirroringServer) {
	s.RegisterService(&RealTimeTrafficMirroring_ServiceDesc, srv)
}

func _RealTimeTrafficMirroring_RealTimeTrafficMirroring_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.HttpReqAndRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RealTimeTrafficMirroringServer).RealTimeTrafficMirroring(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RealTimeTrafficMirroring_RealTimeTrafficMirroring_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RealTimeTrafficMirroringServer).RealTimeTrafficMirroring(ctx, req.(*HttpStructureStandard.HttpReqAndRes))
	}
	return interceptor(ctx, in, info, handler)
}

// RealTimeTrafficMirroring_ServiceDesc is the grpc.ServiceDesc for RealTimeTrafficMirroring service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RealTimeTrafficMirroring_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.RealTimeTrafficMirroring",
	HandlerType: (*RealTimeTrafficMirroringServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RealTimeTrafficMirroring",
			Handler:    _RealTimeTrafficMirroring_RealTimeTrafficMirroring_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	RegisterServerRoutingList_RegisterServerList_FullMethodName = "/BurpMorePossibilityApi.RegisterServerRoutingList/RegisterServerList"
)

// RegisterServerRoutingListClient is the client API for RegisterServerRoutingList service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegisterServerRoutingListClient interface {
	RegisterServerList(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (*ServiceRegisterRoutingList, error)
}

type registerServerRoutingListClient struct {
	cc grpc.ClientConnInterface
}

func NewRegisterServerRoutingListClient(cc grpc.ClientConnInterface) RegisterServerRoutingListClient {
	return &registerServerRoutingListClient{cc}
}

func (c *registerServerRoutingListClient) RegisterServerList(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (*ServiceRegisterRoutingList, error) {
	out := new(ServiceRegisterRoutingList)
	err := c.cc.Invoke(ctx, RegisterServerRoutingList_RegisterServerList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegisterServerRoutingListServer is the server API for RegisterServerRoutingList service.
// All implementations must embed UnimplementedRegisterServerRoutingListServer
// for forward compatibility
type RegisterServerRoutingListServer interface {
	RegisterServerList(context.Context, *HttpStructureStandard.Str) (*ServiceRegisterRoutingList, error)
	mustEmbedUnimplementedRegisterServerRoutingListServer()
}

// UnimplementedRegisterServerRoutingListServer must be embedded to have forward compatible implementations.
type UnimplementedRegisterServerRoutingListServer struct {
}

func (UnimplementedRegisterServerRoutingListServer) RegisterServerList(context.Context, *HttpStructureStandard.Str) (*ServiceRegisterRoutingList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterServerList not implemented")
}
func (UnimplementedRegisterServerRoutingListServer) mustEmbedUnimplementedRegisterServerRoutingListServer() {
}

// UnsafeRegisterServerRoutingListServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegisterServerRoutingListServer will
// result in compilation errors.
type UnsafeRegisterServerRoutingListServer interface {
	mustEmbedUnimplementedRegisterServerRoutingListServer()
}

func RegisterRegisterServerRoutingListServer(s grpc.ServiceRegistrar, srv RegisterServerRoutingListServer) {
	s.RegisterService(&RegisterServerRoutingList_ServiceDesc, srv)
}

func _RegisterServerRoutingList_RegisterServerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.Str)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServerRoutingListServer).RegisterServerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegisterServerRoutingList_RegisterServerList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServerRoutingListServer).RegisterServerList(ctx, req.(*HttpStructureStandard.Str))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterServerRoutingList_ServiceDesc is the grpc.ServiceDesc for RegisterServerRoutingList service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegisterServerRoutingList_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.RegisterServerRoutingList",
	HandlerType: (*RegisterServerRoutingListServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterServerList",
			Handler:    _RegisterServerRoutingList_RegisterServerList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	ScoutServer_AddHttpEditorEncryptAndDecryptKeyValue_FullMethodName = "/BurpMorePossibilityApi.ScoutServer/addHttpEditorEncryptAndDecryptKeyValue"
	ScoutServer_AddHttpKeyValuePair_FullMethodName                    = "/BurpMorePossibilityApi.ScoutServer/AddHttpKeyValuePair"
)

// ScoutServerClient is the client API for ScoutServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScoutServerClient interface {
	// 添加http编辑器加解密键值对 参数为http编辑组件名称以及key、value
	AddHttpEditorEncryptAndDecryptKeyValue(ctx context.Context, in *HttpEditorKeyValue, opts ...grpc.CallOption) (*HttpStructureStandard.ProcessingStatus, error)
	AddHttpKeyValuePair(ctx context.Context, in *HttpKeyValuePair, opts ...grpc.CallOption) (*HttpStructureStandard.Boole, error)
}

type scoutServerClient struct {
	cc grpc.ClientConnInterface
}

func NewScoutServerClient(cc grpc.ClientConnInterface) ScoutServerClient {
	return &scoutServerClient{cc}
}

func (c *scoutServerClient) AddHttpEditorEncryptAndDecryptKeyValue(ctx context.Context, in *HttpEditorKeyValue, opts ...grpc.CallOption) (*HttpStructureStandard.ProcessingStatus, error) {
	out := new(HttpStructureStandard.ProcessingStatus)
	err := c.cc.Invoke(ctx, ScoutServer_AddHttpEditorEncryptAndDecryptKeyValue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServerClient) AddHttpKeyValuePair(ctx context.Context, in *HttpKeyValuePair, opts ...grpc.CallOption) (*HttpStructureStandard.Boole, error) {
	out := new(HttpStructureStandard.Boole)
	err := c.cc.Invoke(ctx, ScoutServer_AddHttpKeyValuePair_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScoutServerServer is the server API for ScoutServer service.
// All implementations must embed UnimplementedScoutServerServer
// for forward compatibility
type ScoutServerServer interface {
	// 添加http编辑器加解密键值对 参数为http编辑组件名称以及key、value
	AddHttpEditorEncryptAndDecryptKeyValue(context.Context, *HttpEditorKeyValue) (*HttpStructureStandard.ProcessingStatus, error)
	AddHttpKeyValuePair(context.Context, *HttpKeyValuePair) (*HttpStructureStandard.Boole, error)
	mustEmbedUnimplementedScoutServerServer()
}

// UnimplementedScoutServerServer must be embedded to have forward compatible implementations.
type UnimplementedScoutServerServer struct {
}

func (UnimplementedScoutServerServer) AddHttpEditorEncryptAndDecryptKeyValue(context.Context, *HttpEditorKeyValue) (*HttpStructureStandard.ProcessingStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHttpEditorEncryptAndDecryptKeyValue not implemented")
}
func (UnimplementedScoutServerServer) AddHttpKeyValuePair(context.Context, *HttpKeyValuePair) (*HttpStructureStandard.Boole, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHttpKeyValuePair not implemented")
}
func (UnimplementedScoutServerServer) mustEmbedUnimplementedScoutServerServer() {}

// UnsafeScoutServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScoutServerServer will
// result in compilation errors.
type UnsafeScoutServerServer interface {
	mustEmbedUnimplementedScoutServerServer()
}

func RegisterScoutServerServer(s grpc.ServiceRegistrar, srv ScoutServerServer) {
	s.RegisterService(&ScoutServer_ServiceDesc, srv)
}

func _ScoutServer_AddHttpEditorEncryptAndDecryptKeyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpEditorKeyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServerServer).AddHttpEditorEncryptAndDecryptKeyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutServer_AddHttpEditorEncryptAndDecryptKeyValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServerServer).AddHttpEditorEncryptAndDecryptKeyValue(ctx, req.(*HttpEditorKeyValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutServer_AddHttpKeyValuePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpKeyValuePair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServerServer).AddHttpKeyValuePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutServer_AddHttpKeyValuePair_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServerServer).AddHttpKeyValuePair(ctx, req.(*HttpKeyValuePair))
	}
	return interceptor(ctx, in, info, handler)
}

// ScoutServer_ServiceDesc is the grpc.ServiceDesc for ScoutServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ScoutServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.ScoutServer",
	HandlerType: (*ScoutServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addHttpEditorEncryptAndDecryptKeyValue",
			Handler:    _ScoutServer_AddHttpEditorEncryptAndDecryptKeyValue_Handler,
		},
		{
			MethodName: "AddHttpKeyValuePair",
			Handler:    _ScoutServer_AddHttpKeyValuePair_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	IntruderPayloadProcessorServer_IntruderPayloadProcessor_FullMethodName = "/BurpMorePossibilityApi.IntruderPayloadProcessorServer/IntruderPayloadProcessor"
)

// IntruderPayloadProcessorServerClient is the client API for IntruderPayloadProcessorServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntruderPayloadProcessorServerClient interface {
	// 迭代器载荷处理
	IntruderPayloadProcessor(ctx context.Context, in *PayloadProcessorData, opts ...grpc.CallOption) (*HttpStructureStandard.ByteData, error)
}

type intruderPayloadProcessorServerClient struct {
	cc grpc.ClientConnInterface
}

func NewIntruderPayloadProcessorServerClient(cc grpc.ClientConnInterface) IntruderPayloadProcessorServerClient {
	return &intruderPayloadProcessorServerClient{cc}
}

func (c *intruderPayloadProcessorServerClient) IntruderPayloadProcessor(ctx context.Context, in *PayloadProcessorData, opts ...grpc.CallOption) (*HttpStructureStandard.ByteData, error) {
	out := new(HttpStructureStandard.ByteData)
	err := c.cc.Invoke(ctx, IntruderPayloadProcessorServer_IntruderPayloadProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntruderPayloadProcessorServerServer is the server API for IntruderPayloadProcessorServer service.
// All implementations must embed UnimplementedIntruderPayloadProcessorServerServer
// for forward compatibility
type IntruderPayloadProcessorServerServer interface {
	// 迭代器载荷处理
	IntruderPayloadProcessor(context.Context, *PayloadProcessorData) (*HttpStructureStandard.ByteData, error)
	mustEmbedUnimplementedIntruderPayloadProcessorServerServer()
}

// UnimplementedIntruderPayloadProcessorServerServer must be embedded to have forward compatible implementations.
type UnimplementedIntruderPayloadProcessorServerServer struct {
}

func (UnimplementedIntruderPayloadProcessorServerServer) IntruderPayloadProcessor(context.Context, *PayloadProcessorData) (*HttpStructureStandard.ByteData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntruderPayloadProcessor not implemented")
}
func (UnimplementedIntruderPayloadProcessorServerServer) mustEmbedUnimplementedIntruderPayloadProcessorServerServer() {
}

// UnsafeIntruderPayloadProcessorServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntruderPayloadProcessorServerServer will
// result in compilation errors.
type UnsafeIntruderPayloadProcessorServerServer interface {
	mustEmbedUnimplementedIntruderPayloadProcessorServerServer()
}

func RegisterIntruderPayloadProcessorServerServer(s grpc.ServiceRegistrar, srv IntruderPayloadProcessorServerServer) {
	s.RegisterService(&IntruderPayloadProcessorServer_ServiceDesc, srv)
}

func _IntruderPayloadProcessorServer_IntruderPayloadProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayloadProcessorData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntruderPayloadProcessorServerServer).IntruderPayloadProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntruderPayloadProcessorServer_IntruderPayloadProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntruderPayloadProcessorServerServer).IntruderPayloadProcessor(ctx, req.(*PayloadProcessorData))
	}
	return interceptor(ctx, in, info, handler)
}

// IntruderPayloadProcessorServer_ServiceDesc is the grpc.ServiceDesc for IntruderPayloadProcessorServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IntruderPayloadProcessorServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.IntruderPayloadProcessorServer",
	HandlerType: (*IntruderPayloadProcessorServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IntruderPayloadProcessor",
			Handler:    _IntruderPayloadProcessorServer_IntruderPayloadProcessor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	IntruderPayloadGeneratorServer_IntruderPayloadGeneratorProvider_FullMethodName = "/BurpMorePossibilityApi.IntruderPayloadGeneratorServer/IntruderPayloadGeneratorProvider"
)

// IntruderPayloadGeneratorServerClient is the client API for IntruderPayloadGeneratorServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntruderPayloadGeneratorServerClient interface {
	// 迭代器载荷生成, 服务端流 流终止就为生成结束
	IntruderPayloadGeneratorProvider(ctx context.Context, in *IntruderGeneratorData, opts ...grpc.CallOption) (*PayloadGeneratorResult, error)
}

type intruderPayloadGeneratorServerClient struct {
	cc grpc.ClientConnInterface
}

func NewIntruderPayloadGeneratorServerClient(cc grpc.ClientConnInterface) IntruderPayloadGeneratorServerClient {
	return &intruderPayloadGeneratorServerClient{cc}
}

func (c *intruderPayloadGeneratorServerClient) IntruderPayloadGeneratorProvider(ctx context.Context, in *IntruderGeneratorData, opts ...grpc.CallOption) (*PayloadGeneratorResult, error) {
	out := new(PayloadGeneratorResult)
	err := c.cc.Invoke(ctx, IntruderPayloadGeneratorServer_IntruderPayloadGeneratorProvider_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntruderPayloadGeneratorServerServer is the server API for IntruderPayloadGeneratorServer service.
// All implementations must embed UnimplementedIntruderPayloadGeneratorServerServer
// for forward compatibility
type IntruderPayloadGeneratorServerServer interface {
	// 迭代器载荷生成, 服务端流 流终止就为生成结束
	IntruderPayloadGeneratorProvider(context.Context, *IntruderGeneratorData) (*PayloadGeneratorResult, error)
	mustEmbedUnimplementedIntruderPayloadGeneratorServerServer()
}

// UnimplementedIntruderPayloadGeneratorServerServer must be embedded to have forward compatible implementations.
type UnimplementedIntruderPayloadGeneratorServerServer struct {
}

func (UnimplementedIntruderPayloadGeneratorServerServer) IntruderPayloadGeneratorProvider(context.Context, *IntruderGeneratorData) (*PayloadGeneratorResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntruderPayloadGeneratorProvider not implemented")
}
func (UnimplementedIntruderPayloadGeneratorServerServer) mustEmbedUnimplementedIntruderPayloadGeneratorServerServer() {
}

// UnsafeIntruderPayloadGeneratorServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntruderPayloadGeneratorServerServer will
// result in compilation errors.
type UnsafeIntruderPayloadGeneratorServerServer interface {
	mustEmbedUnimplementedIntruderPayloadGeneratorServerServer()
}

func RegisterIntruderPayloadGeneratorServerServer(s grpc.ServiceRegistrar, srv IntruderPayloadGeneratorServerServer) {
	s.RegisterService(&IntruderPayloadGeneratorServer_ServiceDesc, srv)
}

func _IntruderPayloadGeneratorServer_IntruderPayloadGeneratorProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntruderGeneratorData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntruderPayloadGeneratorServerServer).IntruderPayloadGeneratorProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntruderPayloadGeneratorServer_IntruderPayloadGeneratorProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntruderPayloadGeneratorServerServer).IntruderPayloadGeneratorProvider(ctx, req.(*IntruderGeneratorData))
	}
	return interceptor(ctx, in, info, handler)
}

// IntruderPayloadGeneratorServer_ServiceDesc is the grpc.ServiceDesc for IntruderPayloadGeneratorServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IntruderPayloadGeneratorServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.IntruderPayloadGeneratorServer",
	HandlerType: (*IntruderPayloadGeneratorServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IntruderPayloadGeneratorProvider",
			Handler:    _IntruderPayloadGeneratorServer_IntruderPayloadGeneratorProvider_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	HttpReqEditBoxAssist_ReqHttpEdit_FullMethodName      = "/BurpMorePossibilityApi.HttpReqEditBoxAssist/ReqHttpEdit"
	HttpReqEditBoxAssist_IsReqHttpEditFor_FullMethodName = "/BurpMorePossibilityApi.HttpReqEditBoxAssist/IsReqHttpEditFor"
)

// HttpReqEditBoxAssistClient is the client API for HttpReqEditBoxAssist service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HttpReqEditBoxAssistClient interface {
	ReqHttpEdit(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.ByteData, error)
	IsReqHttpEditFor(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.Boole, error)
}

type httpReqEditBoxAssistClient struct {
	cc grpc.ClientConnInterface
}

func NewHttpReqEditBoxAssistClient(cc grpc.ClientConnInterface) HttpReqEditBoxAssistClient {
	return &httpReqEditBoxAssistClient{cc}
}

func (c *httpReqEditBoxAssistClient) ReqHttpEdit(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.ByteData, error) {
	out := new(HttpStructureStandard.ByteData)
	err := c.cc.Invoke(ctx, HttpReqEditBoxAssist_ReqHttpEdit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *httpReqEditBoxAssistClient) IsReqHttpEditFor(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.Boole, error) {
	out := new(HttpStructureStandard.Boole)
	err := c.cc.Invoke(ctx, HttpReqEditBoxAssist_IsReqHttpEditFor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HttpReqEditBoxAssistServer is the server API for HttpReqEditBoxAssist service.
// All implementations must embed UnimplementedHttpReqEditBoxAssistServer
// for forward compatibility
type HttpReqEditBoxAssistServer interface {
	ReqHttpEdit(context.Context, *HttpEditBoxData) (*HttpStructureStandard.ByteData, error)
	IsReqHttpEditFor(context.Context, *HttpEditBoxData) (*HttpStructureStandard.Boole, error)
	mustEmbedUnimplementedHttpReqEditBoxAssistServer()
}

// UnimplementedHttpReqEditBoxAssistServer must be embedded to have forward compatible implementations.
type UnimplementedHttpReqEditBoxAssistServer struct {
}

func (UnimplementedHttpReqEditBoxAssistServer) ReqHttpEdit(context.Context, *HttpEditBoxData) (*HttpStructureStandard.ByteData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqHttpEdit not implemented")
}
func (UnimplementedHttpReqEditBoxAssistServer) IsReqHttpEditFor(context.Context, *HttpEditBoxData) (*HttpStructureStandard.Boole, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsReqHttpEditFor not implemented")
}
func (UnimplementedHttpReqEditBoxAssistServer) mustEmbedUnimplementedHttpReqEditBoxAssistServer() {}

// UnsafeHttpReqEditBoxAssistServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HttpReqEditBoxAssistServer will
// result in compilation errors.
type UnsafeHttpReqEditBoxAssistServer interface {
	mustEmbedUnimplementedHttpReqEditBoxAssistServer()
}

func RegisterHttpReqEditBoxAssistServer(s grpc.ServiceRegistrar, srv HttpReqEditBoxAssistServer) {
	s.RegisterService(&HttpReqEditBoxAssist_ServiceDesc, srv)
}

func _HttpReqEditBoxAssist_ReqHttpEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpEditBoxData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpReqEditBoxAssistServer).ReqHttpEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpReqEditBoxAssist_ReqHttpEdit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpReqEditBoxAssistServer).ReqHttpEdit(ctx, req.(*HttpEditBoxData))
	}
	return interceptor(ctx, in, info, handler)
}

func _HttpReqEditBoxAssist_IsReqHttpEditFor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpEditBoxData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpReqEditBoxAssistServer).IsReqHttpEditFor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpReqEditBoxAssist_IsReqHttpEditFor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpReqEditBoxAssistServer).IsReqHttpEditFor(ctx, req.(*HttpEditBoxData))
	}
	return interceptor(ctx, in, info, handler)
}

// HttpReqEditBoxAssist_ServiceDesc is the grpc.ServiceDesc for HttpReqEditBoxAssist service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HttpReqEditBoxAssist_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.HttpReqEditBoxAssist",
	HandlerType: (*HttpReqEditBoxAssistServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReqHttpEdit",
			Handler:    _HttpReqEditBoxAssist_ReqHttpEdit_Handler,
		},
		{
			MethodName: "IsReqHttpEditFor",
			Handler:    _HttpReqEditBoxAssist_IsReqHttpEditFor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	HttpResEditBoxAssist_ResHttpEdit_FullMethodName      = "/BurpMorePossibilityApi.HttpResEditBoxAssist/ResHttpEdit"
	HttpResEditBoxAssist_IsResHttpEditFor_FullMethodName = "/BurpMorePossibilityApi.HttpResEditBoxAssist/IsResHttpEditFor"
)

// HttpResEditBoxAssistClient is the client API for HttpResEditBoxAssist service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HttpResEditBoxAssistClient interface {
	ResHttpEdit(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.ByteData, error)
	IsResHttpEditFor(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.Boole, error)
}

type httpResEditBoxAssistClient struct {
	cc grpc.ClientConnInterface
}

func NewHttpResEditBoxAssistClient(cc grpc.ClientConnInterface) HttpResEditBoxAssistClient {
	return &httpResEditBoxAssistClient{cc}
}

func (c *httpResEditBoxAssistClient) ResHttpEdit(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.ByteData, error) {
	out := new(HttpStructureStandard.ByteData)
	err := c.cc.Invoke(ctx, HttpResEditBoxAssist_ResHttpEdit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *httpResEditBoxAssistClient) IsResHttpEditFor(ctx context.Context, in *HttpEditBoxData, opts ...grpc.CallOption) (*HttpStructureStandard.Boole, error) {
	out := new(HttpStructureStandard.Boole)
	err := c.cc.Invoke(ctx, HttpResEditBoxAssist_IsResHttpEditFor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HttpResEditBoxAssistServer is the server API for HttpResEditBoxAssist service.
// All implementations must embed UnimplementedHttpResEditBoxAssistServer
// for forward compatibility
type HttpResEditBoxAssistServer interface {
	ResHttpEdit(context.Context, *HttpEditBoxData) (*HttpStructureStandard.ByteData, error)
	IsResHttpEditFor(context.Context, *HttpEditBoxData) (*HttpStructureStandard.Boole, error)
	mustEmbedUnimplementedHttpResEditBoxAssistServer()
}

// UnimplementedHttpResEditBoxAssistServer must be embedded to have forward compatible implementations.
type UnimplementedHttpResEditBoxAssistServer struct {
}

func (UnimplementedHttpResEditBoxAssistServer) ResHttpEdit(context.Context, *HttpEditBoxData) (*HttpStructureStandard.ByteData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResHttpEdit not implemented")
}
func (UnimplementedHttpResEditBoxAssistServer) IsResHttpEditFor(context.Context, *HttpEditBoxData) (*HttpStructureStandard.Boole, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsResHttpEditFor not implemented")
}
func (UnimplementedHttpResEditBoxAssistServer) mustEmbedUnimplementedHttpResEditBoxAssistServer() {}

// UnsafeHttpResEditBoxAssistServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HttpResEditBoxAssistServer will
// result in compilation errors.
type UnsafeHttpResEditBoxAssistServer interface {
	mustEmbedUnimplementedHttpResEditBoxAssistServer()
}

func RegisterHttpResEditBoxAssistServer(s grpc.ServiceRegistrar, srv HttpResEditBoxAssistServer) {
	s.RegisterService(&HttpResEditBoxAssist_ServiceDesc, srv)
}

func _HttpResEditBoxAssist_ResHttpEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpEditBoxData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpResEditBoxAssistServer).ResHttpEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpResEditBoxAssist_ResHttpEdit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpResEditBoxAssistServer).ResHttpEdit(ctx, req.(*HttpEditBoxData))
	}
	return interceptor(ctx, in, info, handler)
}

func _HttpResEditBoxAssist_IsResHttpEditFor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpEditBoxData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpResEditBoxAssistServer).IsResHttpEditFor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpResEditBoxAssist_IsResHttpEditFor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpResEditBoxAssistServer).IsResHttpEditFor(ctx, req.(*HttpEditBoxData))
	}
	return interceptor(ctx, in, info, handler)
}

// HttpResEditBoxAssist_ServiceDesc is the grpc.ServiceDesc for HttpResEditBoxAssist service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HttpResEditBoxAssist_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.HttpResEditBoxAssist",
	HandlerType: (*HttpResEditBoxAssistServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResHttpEdit",
			Handler:    _HttpResEditBoxAssist_ResHttpEdit_Handler,
		},
		{
			MethodName: "IsResHttpEditFor",
			Handler:    _HttpResEditBoxAssist_IsResHttpEditFor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	ContextMenuItemsProvider_MenuItemsProvider_FullMethodName = "/BurpMorePossibilityApi.ContextMenuItemsProvider/MenuItemsProvider"
)

// ContextMenuItemsProviderClient is the client API for ContextMenuItemsProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContextMenuItemsProviderClient interface {
	MenuItemsProvider(ctx context.Context, in *ContextMenuItems, opts ...grpc.CallOption) (*MenuItemsReturn, error)
}

type contextMenuItemsProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewContextMenuItemsProviderClient(cc grpc.ClientConnInterface) ContextMenuItemsProviderClient {
	return &contextMenuItemsProviderClient{cc}
}

func (c *contextMenuItemsProviderClient) MenuItemsProvider(ctx context.Context, in *ContextMenuItems, opts ...grpc.CallOption) (*MenuItemsReturn, error) {
	out := new(MenuItemsReturn)
	err := c.cc.Invoke(ctx, ContextMenuItemsProvider_MenuItemsProvider_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContextMenuItemsProviderServer is the server API for ContextMenuItemsProvider service.
// All implementations must embed UnimplementedContextMenuItemsProviderServer
// for forward compatibility
type ContextMenuItemsProviderServer interface {
	MenuItemsProvider(context.Context, *ContextMenuItems) (*MenuItemsReturn, error)
	mustEmbedUnimplementedContextMenuItemsProviderServer()
}

// UnimplementedContextMenuItemsProviderServer must be embedded to have forward compatible implementations.
type UnimplementedContextMenuItemsProviderServer struct {
}

func (UnimplementedContextMenuItemsProviderServer) MenuItemsProvider(context.Context, *ContextMenuItems) (*MenuItemsReturn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuItemsProvider not implemented")
}
func (UnimplementedContextMenuItemsProviderServer) mustEmbedUnimplementedContextMenuItemsProviderServer() {
}

// UnsafeContextMenuItemsProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContextMenuItemsProviderServer will
// result in compilation errors.
type UnsafeContextMenuItemsProviderServer interface {
	mustEmbedUnimplementedContextMenuItemsProviderServer()
}

func RegisterContextMenuItemsProviderServer(s grpc.ServiceRegistrar, srv ContextMenuItemsProviderServer) {
	s.RegisterService(&ContextMenuItemsProvider_ServiceDesc, srv)
}

func _ContextMenuItemsProvider_MenuItemsProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextMenuItems)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContextMenuItemsProviderServer).MenuItemsProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ContextMenuItemsProvider_MenuItemsProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContextMenuItemsProviderServer).MenuItemsProvider(ctx, req.(*ContextMenuItems))
	}
	return interceptor(ctx, in, info, handler)
}

// ContextMenuItemsProvider_ServiceDesc is the grpc.ServiceDesc for ContextMenuItemsProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContextMenuItemsProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.ContextMenuItemsProvider",
	HandlerType: (*ContextMenuItemsProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MenuItemsProvider",
			Handler:    _ContextMenuItemsProvider_MenuItemsProvider_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	GetConTextMenuItemsServer_GetConTextMenuItems_FullMethodName = "/BurpMorePossibilityApi.GetConTextMenuItemsServer/GetConTextMenuItems"
)

// GetConTextMenuItemsServerClient is the client API for GetConTextMenuItemsServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GetConTextMenuItemsServerClient interface {
	GetConTextMenuItems(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (*MenuInfo, error)
}

type getConTextMenuItemsServerClient struct {
	cc grpc.ClientConnInterface
}

func NewGetConTextMenuItemsServerClient(cc grpc.ClientConnInterface) GetConTextMenuItemsServerClient {
	return &getConTextMenuItemsServerClient{cc}
}

func (c *getConTextMenuItemsServerClient) GetConTextMenuItems(ctx context.Context, in *HttpStructureStandard.Str, opts ...grpc.CallOption) (*MenuInfo, error) {
	out := new(MenuInfo)
	err := c.cc.Invoke(ctx, GetConTextMenuItemsServer_GetConTextMenuItems_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetConTextMenuItemsServerServer is the server API for GetConTextMenuItemsServer service.
// All implementations must embed UnimplementedGetConTextMenuItemsServerServer
// for forward compatibility
type GetConTextMenuItemsServerServer interface {
	GetConTextMenuItems(context.Context, *HttpStructureStandard.Str) (*MenuInfo, error)
	mustEmbedUnimplementedGetConTextMenuItemsServerServer()
}

// UnimplementedGetConTextMenuItemsServerServer must be embedded to have forward compatible implementations.
type UnimplementedGetConTextMenuItemsServerServer struct {
}

func (UnimplementedGetConTextMenuItemsServerServer) GetConTextMenuItems(context.Context, *HttpStructureStandard.Str) (*MenuInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConTextMenuItems not implemented")
}
func (UnimplementedGetConTextMenuItemsServerServer) mustEmbedUnimplementedGetConTextMenuItemsServerServer() {
}

// UnsafeGetConTextMenuItemsServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GetConTextMenuItemsServerServer will
// result in compilation errors.
type UnsafeGetConTextMenuItemsServerServer interface {
	mustEmbedUnimplementedGetConTextMenuItemsServerServer()
}

func RegisterGetConTextMenuItemsServerServer(s grpc.ServiceRegistrar, srv GetConTextMenuItemsServerServer) {
	s.RegisterService(&GetConTextMenuItemsServer_ServiceDesc, srv)
}

func _GetConTextMenuItemsServer_GetConTextMenuItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.Str)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetConTextMenuItemsServerServer).GetConTextMenuItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GetConTextMenuItemsServer_GetConTextMenuItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetConTextMenuItemsServerServer).GetConTextMenuItems(ctx, req.(*HttpStructureStandard.Str))
	}
	return interceptor(ctx, in, info, handler)
}

// GetConTextMenuItemsServer_ServiceDesc is the grpc.ServiceDesc for GetConTextMenuItemsServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GetConTextMenuItemsServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.GetConTextMenuItemsServer",
	HandlerType: (*GetConTextMenuItemsServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConTextMenuItems",
			Handler:    _GetConTextMenuItemsServer_GetConTextMenuItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	ProxyRequestHandler_ProxyHandleRequestReceived_FullMethodName = "/BurpMorePossibilityApi.ProxyRequestHandler/ProxyHandleRequestReceived"
)

// ProxyRequestHandlerClient is the client API for ProxyRequestHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyRequestHandlerClient interface {
	ProxyHandleRequestReceived(ctx context.Context, in *HttpStructureStandard.HttpReqGroup, opts ...grpc.CallOption) (*ProxyRequestAction, error)
}

type proxyRequestHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyRequestHandlerClient(cc grpc.ClientConnInterface) ProxyRequestHandlerClient {
	return &proxyRequestHandlerClient{cc}
}

func (c *proxyRequestHandlerClient) ProxyHandleRequestReceived(ctx context.Context, in *HttpStructureStandard.HttpReqGroup, opts ...grpc.CallOption) (*ProxyRequestAction, error) {
	out := new(ProxyRequestAction)
	err := c.cc.Invoke(ctx, ProxyRequestHandler_ProxyHandleRequestReceived_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyRequestHandlerServer is the server API for ProxyRequestHandler service.
// All implementations must embed UnimplementedProxyRequestHandlerServer
// for forward compatibility
type ProxyRequestHandlerServer interface {
	ProxyHandleRequestReceived(context.Context, *HttpStructureStandard.HttpReqGroup) (*ProxyRequestAction, error)
	mustEmbedUnimplementedProxyRequestHandlerServer()
}

// UnimplementedProxyRequestHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedProxyRequestHandlerServer struct {
}

func (UnimplementedProxyRequestHandlerServer) ProxyHandleRequestReceived(context.Context, *HttpStructureStandard.HttpReqGroup) (*ProxyRequestAction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProxyHandleRequestReceived not implemented")
}
func (UnimplementedProxyRequestHandlerServer) mustEmbedUnimplementedProxyRequestHandlerServer() {}

// UnsafeProxyRequestHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyRequestHandlerServer will
// result in compilation errors.
type UnsafeProxyRequestHandlerServer interface {
	mustEmbedUnimplementedProxyRequestHandlerServer()
}

func RegisterProxyRequestHandlerServer(s grpc.ServiceRegistrar, srv ProxyRequestHandlerServer) {
	s.RegisterService(&ProxyRequestHandler_ServiceDesc, srv)
}

func _ProxyRequestHandler_ProxyHandleRequestReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.HttpReqGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyRequestHandlerServer).ProxyHandleRequestReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProxyRequestHandler_ProxyHandleRequestReceived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyRequestHandlerServer).ProxyHandleRequestReceived(ctx, req.(*HttpStructureStandard.HttpReqGroup))
	}
	return interceptor(ctx, in, info, handler)
}

// ProxyRequestHandler_ServiceDesc is the grpc.ServiceDesc for ProxyRequestHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProxyRequestHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.ProxyRequestHandler",
	HandlerType: (*ProxyRequestHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProxyHandleRequestReceived",
			Handler:    _ProxyRequestHandler_ProxyHandleRequestReceived_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	ProxyResponseHandler_ProxyHandleResponseReceived_FullMethodName = "/BurpMorePossibilityApi.ProxyResponseHandler/ProxyHandleResponseReceived"
)

// ProxyResponseHandlerClient is the client API for ProxyResponseHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyResponseHandlerClient interface {
	ProxyHandleResponseReceived(ctx context.Context, in *HttpStructureStandard.HttpReqAndRes, opts ...grpc.CallOption) (*ProxyResponseAction, error)
}

type proxyResponseHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyResponseHandlerClient(cc grpc.ClientConnInterface) ProxyResponseHandlerClient {
	return &proxyResponseHandlerClient{cc}
}

func (c *proxyResponseHandlerClient) ProxyHandleResponseReceived(ctx context.Context, in *HttpStructureStandard.HttpReqAndRes, opts ...grpc.CallOption) (*ProxyResponseAction, error) {
	out := new(ProxyResponseAction)
	err := c.cc.Invoke(ctx, ProxyResponseHandler_ProxyHandleResponseReceived_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyResponseHandlerServer is the server API for ProxyResponseHandler service.
// All implementations must embed UnimplementedProxyResponseHandlerServer
// for forward compatibility
type ProxyResponseHandlerServer interface {
	ProxyHandleResponseReceived(context.Context, *HttpStructureStandard.HttpReqAndRes) (*ProxyResponseAction, error)
	mustEmbedUnimplementedProxyResponseHandlerServer()
}

// UnimplementedProxyResponseHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedProxyResponseHandlerServer struct {
}

func (UnimplementedProxyResponseHandlerServer) ProxyHandleResponseReceived(context.Context, *HttpStructureStandard.HttpReqAndRes) (*ProxyResponseAction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProxyHandleResponseReceived not implemented")
}
func (UnimplementedProxyResponseHandlerServer) mustEmbedUnimplementedProxyResponseHandlerServer() {}

// UnsafeProxyResponseHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyResponseHandlerServer will
// result in compilation errors.
type UnsafeProxyResponseHandlerServer interface {
	mustEmbedUnimplementedProxyResponseHandlerServer()
}

func RegisterProxyResponseHandlerServer(s grpc.ServiceRegistrar, srv ProxyResponseHandlerServer) {
	s.RegisterService(&ProxyResponseHandler_ServiceDesc, srv)
}

func _ProxyResponseHandler_ProxyHandleResponseReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpStructureStandard.HttpReqAndRes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyResponseHandlerServer).ProxyHandleResponseReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProxyResponseHandler_ProxyHandleResponseReceived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyResponseHandlerServer).ProxyHandleResponseReceived(ctx, req.(*HttpStructureStandard.HttpReqAndRes))
	}
	return interceptor(ctx, in, info, handler)
}

// ProxyResponseHandler_ServiceDesc is the grpc.ServiceDesc for ProxyResponseHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProxyResponseHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.ProxyResponseHandler",
	HandlerType: (*ProxyResponseHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProxyHandleResponseReceived",
			Handler:    _ProxyResponseHandler_ProxyHandleResponseReceived_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}

const (
	HttpFlowHandler_HttpHandleRequestReceived_FullMethodName  = "/BurpMorePossibilityApi.HttpFlowHandler/HttpHandleRequestReceived"
	HttpFlowHandler_HttpHandleResponseReceived_FullMethodName = "/BurpMorePossibilityApi.HttpFlowHandler/HttpHandleResponseReceived"
)

// HttpFlowHandlerClient is the client API for HttpFlowHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HttpFlowHandlerClient interface {
	HttpHandleRequestReceived(ctx context.Context, in *HttpFlowReqData, opts ...grpc.CallOption) (*HttpRequestAction, error)
	HttpHandleResponseReceived(ctx context.Context, in *HttpFlowResData, opts ...grpc.CallOption) (*HttpResponseAction, error)
}

type httpFlowHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewHttpFlowHandlerClient(cc grpc.ClientConnInterface) HttpFlowHandlerClient {
	return &httpFlowHandlerClient{cc}
}

func (c *httpFlowHandlerClient) HttpHandleRequestReceived(ctx context.Context, in *HttpFlowReqData, opts ...grpc.CallOption) (*HttpRequestAction, error) {
	out := new(HttpRequestAction)
	err := c.cc.Invoke(ctx, HttpFlowHandler_HttpHandleRequestReceived_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *httpFlowHandlerClient) HttpHandleResponseReceived(ctx context.Context, in *HttpFlowResData, opts ...grpc.CallOption) (*HttpResponseAction, error) {
	out := new(HttpResponseAction)
	err := c.cc.Invoke(ctx, HttpFlowHandler_HttpHandleResponseReceived_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HttpFlowHandlerServer is the server API for HttpFlowHandler service.
// All implementations must embed UnimplementedHttpFlowHandlerServer
// for forward compatibility
type HttpFlowHandlerServer interface {
	HttpHandleRequestReceived(context.Context, *HttpFlowReqData) (*HttpRequestAction, error)
	HttpHandleResponseReceived(context.Context, *HttpFlowResData) (*HttpResponseAction, error)
	mustEmbedUnimplementedHttpFlowHandlerServer()
}

// UnimplementedHttpFlowHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedHttpFlowHandlerServer struct {
}

func (UnimplementedHttpFlowHandlerServer) HttpHandleRequestReceived(context.Context, *HttpFlowReqData) (*HttpRequestAction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HttpHandleRequestReceived not implemented")
}
func (UnimplementedHttpFlowHandlerServer) HttpHandleResponseReceived(context.Context, *HttpFlowResData) (*HttpResponseAction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HttpHandleResponseReceived not implemented")
}
func (UnimplementedHttpFlowHandlerServer) mustEmbedUnimplementedHttpFlowHandlerServer() {}

// UnsafeHttpFlowHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HttpFlowHandlerServer will
// result in compilation errors.
type UnsafeHttpFlowHandlerServer interface {
	mustEmbedUnimplementedHttpFlowHandlerServer()
}

func RegisterHttpFlowHandlerServer(s grpc.ServiceRegistrar, srv HttpFlowHandlerServer) {
	s.RegisterService(&HttpFlowHandler_ServiceDesc, srv)
}

func _HttpFlowHandler_HttpHandleRequestReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpFlowReqData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpFlowHandlerServer).HttpHandleRequestReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpFlowHandler_HttpHandleRequestReceived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpFlowHandlerServer).HttpHandleRequestReceived(ctx, req.(*HttpFlowReqData))
	}
	return interceptor(ctx, in, info, handler)
}

func _HttpFlowHandler_HttpHandleResponseReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpFlowResData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HttpFlowHandlerServer).HttpHandleResponseReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HttpFlowHandler_HttpHandleResponseReceived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HttpFlowHandlerServer).HttpHandleResponseReceived(ctx, req.(*HttpFlowResData))
	}
	return interceptor(ctx, in, info, handler)
}

// HttpFlowHandler_ServiceDesc is the grpc.ServiceDesc for HttpFlowHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HttpFlowHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BurpMorePossibilityApi.HttpFlowHandler",
	HandlerType: (*HttpFlowHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HttpHandleRequestReceived",
			Handler:    _HttpFlowHandler_HttpHandleRequestReceived_Handler,
		},
		{
			MethodName: "HttpHandleResponseReceived",
			Handler:    _HttpFlowHandler_HttpHandleResponseReceived_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "BurpMorePossibility.proto",
}
